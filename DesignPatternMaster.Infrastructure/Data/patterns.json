[
  {
    "Id": "strategy",
    "Name": "Strategy Pattern",
    "Summary": "アルゴリズムのファミリーを定義し、カプセル化して相互交換可能にするパターン。Open/Closed原則の実現に不可欠。",
    "Category": "Behavioral",
    "Difficulty": "Intermediate",
    "IsModern": true,
    "IsAntiPattern": false,
    "ModernRelevance": "現代のC#開発では、DI（依存性注入）と組み合わせることで真価を発揮します。`IEnumerable<IStrategy>` をコンストラクタで受け取り、実行時に適切な戦略を選択する「Strategy Provider」パターンが一般的です。また、単純な場合は `Func<T>` や `Action<T>` で代用されることもあります。",
    "Sections": [
      {
        "Title": "イントロダクション：条件分岐の排除",
        "Content": "ビジネスロジックの中で `if (type == A) ... else if (type == B) ...` という分岐が頻出する場合、それはStrategyパターンの適用シグナルです。\n\n新しいタイプ `C` が追加されるたびに既存のクラスを修正するのは、バグの温床です（Open/Closed Principle違反）。Strategyパターンは、この分岐をポリモーフィズムによって解決します。",
        "ImagePath": ""
      },
      {
        "Title": "実践的実装：DIとStrategyの融合",
        "Content": "単にインターフェースを作るだけでなく、DIコンテナを活用して戦略を管理するのが現代的な手法です。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "public interface IDiscountStrategy\n{\n    bool CanApply(Order order);\n    decimal ApplyDiscount(decimal total);\n}\n\n// 複数の戦略を定義\npublic class HolidayDiscount : IDiscountStrategy { ... }\npublic class PremiumMemberDiscount : IDiscountStrategy { ... }\n\n// Contextクラス\npublic class OrderService\n{\n    private readonly IEnumerable<IDiscountStrategy> _strategies;\n\n    // DIコンテナが登録されている全ての戦略を注入してくれる\n    public OrderService(IEnumerable<IDiscountStrategy> strategies)\n    {\n        _strategies = strategies;\n    }\n\n    public decimal CalculateTotal(Order order)\n    {\n        var total = order.Amount;\n        // 適用可能な最初の戦略、あるいは全ての戦略を適用するなど柔軟に制御可能\n        foreach (var strategy in _strategies.Where(s => s.CanApply(order)))\n        {\n            total = strategy.ApplyDiscount(total);\n        }\n        return total;\n    }\n}",
          "Description": "この設計なら、新しい割引ルール（戦略）を追加する際、既存の `OrderService` コードを一切変更する必要がありません。単に新しいクラスを作成し、DIに登録するだけです。"
        }
      },
      {
        "Title": "関数型アプローチ：軽量なStrategy",
        "Content": "クラス定義が重すぎる場合は、デリゲートを活用します。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "public void ProcessData(List<int> data, Func<int, bool> filterStrategy)\n{\n    foreach (var item in data.Where(filterStrategy))\n    {\n        Console.WriteLine(item);\n    }\n}\n\n// Usage\nProcessData(list, x => x > 10); // 10より大きい\nProcessData(list, x => x % 2 == 0); // 偶数",
          "Description": "C#のLINQ自体が、実はStrategyパターンの巨大な適用例と言えます（`Where` や `Select` に渡すラムダ式が戦略です）。"
        }
      }
    ]
  },
  {
    "Id": "observer",
    "Name": "Observer Pattern",
    "Summary": "あるオブジェクトの状態が変化したときに、依存するすべてのオブジェクトに自動的に通知するパターン。",
    "Category": "Behavioral",
    "Difficulty": "Intermediate",
    "IsModern": true,
    "IsAntiPattern": false,
    "ModernRelevance": "C#には `event` キーワードや `IObservable<T>` / `IObserver<T>` (Reactive Extensions) が標準で備わっているため、自前で実装することは稀です。特にRxは非同期ストリーム処理において極めて強力です。",
    "Sections": [
      {
        "Title": "イントロダクション：通知の仕組み",
        "Content": "YouTubeのチャンネル登録をイメージしてください。新しい動画がアップロードされたら、登録者全員に通知がいきます。あなたが毎回チャンネルを確認しに行く（ポーリング）必要はありません。\n\nこれがObserverパターンです。**「Publish (発行者)」と「Subscribe (購読者)」の関係**を作ります。",
        "ImagePath": ""
      },
      {
        "Title": "C# 標準の event を使う",
        "Content": "C#では、言語機能としてObserverパターンが組み込まれています。それが `event` です。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "public class YouTuber\n{\n    // イベントの定義\n    public event Action<string> VideoUploaded;\n\n    public void Upload(string title)\n    {\n        Console.WriteLine($\"Uploading {title}...\");\n        // 通知の発行\n        VideoUploaded?.Invoke(title);\n    }\n}\n\npublic class Subscriber\n{\n    public string Name { get; set; }\n\n    public void OnVideoUploaded(string title)\n    {\n        Console.WriteLine($\"{Name}: Wow! New video '{title}' is out!\");\n    }\n}",
          "Description": "eventを使えば、+= 演算子で簡単に購読者を追加できます。"
        }
      },
      {
        "Title": "Reactive Extensions (Rx) への発展",
        "Content": "現代のC#開発、特にGUIアプリや非同期処理においては、`event` よりも **Reactive Extensions (Rx)** が好まれます。Rxは「イベントのコレクション」として時間を扱います。\n\n`System.Reactive` パッケージを使うことで、イベントのフィルタリング、合成、遅延などがLINQのように記述できます。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "// Rxのイメージ（擬似コード）\nyoutuber.VideoUploadedStream\n    .Where(title => title.Contains(\"C#\")) // C#の動画だけ通知\n    .Throttle(TimeSpan.FromSeconds(1)) // 連打防止\n    .Subscribe(title => Console.WriteLine($\"Watch: {title}\"));",
          "Description": "ObserverパターンはRxへと進化し、より宣言的で強力なパラダイムとなりました。"
        }
      }
    ]
  },
  {
    "Id": "factory-method",
    "Name": "Factory Method Pattern",
    "Summary": "インスタンス生成のプロセスをサブクラスに委譲し、クラスの結合度を下げるパターン。",
    "Category": "Creational",
    "Difficulty": "Beginner",
    "IsModern": true,
    "IsAntiPattern": false,
    "ModernRelevance": "DIコンテナ（Dependency Injection）がファクトリーの役割を担うことが多いため、手動でFactoryクラスを作る機会は減りました。しかし、動的な生成ロジックが必要な場合や、ライブラリ設計においては依然として重要です。",
    "Sections": [
      {
        "Title": "イントロダクション：newの何が悪い？",
        "Content": "コードの中で `new ConcreteClass()` と書くと、そのクラスに強く依存してしまいます。将来的に `ConcreteClass` を `BetterConcreteClass` に変えたい場合、すべての `new` を書き直さなければなりません。\n\nFactory Methodパターンは、「生成」という行為をメソッドに切り出し、ポリモーフィズムを使って生成するクラスを切り替えられるようにします。",
        "ImagePath": ""
      },
      {
        "Title": "構造と実装",
        "Content": "Creator（作成者）クラスが `CreateProduct` という抽象メソッドを持ち、ConcreteCreator（具体的な作成者）がそれを実装して具体的な製品（Product）を返します。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "public abstract class Creator\n{\n    // Factory Method\n    public abstract IProduct FactoryMethod();\n\n    public void Operation()\n    {\n        var product = FactoryMethod();\n        product.DoStuff();\n    }\n}\n\npublic class ConcreteCreatorA : Creator\n{\n    public override IProduct FactoryMethod() => new ConcreteProductA();\n}",
          "Description": "Creatorクラスは具体的なProductを知りません。知っているのはIProductインターフェースだけです。"
        }
      }
    ]
  },
  {
    "Id": "adapter",
    "Name": "Adapter Pattern",
    "Summary": "互換性のないインターフェースを持つクラス同士を接続し、一緒に動作させるパターン。",
    "Category": "Structural",
    "Difficulty": "Beginner",
    "IsModern": true,
    "IsAntiPattern": false,
    "ModernRelevance": "非常に一般的です。特にサードパーティ製のライブラリを自分のアプリケーションのインターフェースに合わせてラップする場合や、レガシーコードとの統合によく使われます。",
    "Sections": [
      {
        "Title": "イントロダクション：変換プラグ",
        "Content": "海外旅行に行ったとき、コンセントの形状が合わなくて困ったことはありませんか？その時に使う「変換プラグ」こそがAdapterパターンです。\n\nプログラムでも、既存のクラス（Adaptee）を新しいインターフェース（Target）として使いたい場合があります。",
        "ImagePath": ""
      },
      {
        "Title": "実装例",
        "Content": "継承を使う方法と、委譲（コンポジション）を使う方法がありますが、C#では委譲が推奨されます。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "// 既存のクラス (変更できない)\npublic class OldSystem\n{\n    public void SpecificRequest() => Console.WriteLine(\"Old request\");\n}\n\n// 新しいインターフェース\npublic interface ITarget\n{\n    void Request();\n}\n\n// Adapter\npublic class Adapter : ITarget\n{\n    private readonly OldSystem _oldSystem;\n\n    public Adapter(OldSystem oldSystem)\n    {\n        _oldSystem = oldSystem;\n    }\n\n    public void Request()\n    {\n        // 呼び出しを変換\n        _oldSystem.SpecificRequest();\n    }\n}",
          "Description": "Adapterクラスが間に入ることで、ClientはOldSystemの実装を知らずに利用できます。"
        }
      }
    ]
  },
  {
    "Id": "command",
    "Name": "Command Pattern",
    "Summary": "要求をオブジェクトとしてカプセル化し、パラメータ化、キューイング、ログ記録、そして操作の取り消し（Undo）を可能にするパターン。",
    "Category": "Behavioral",
    "Difficulty": "Advanced",
    "IsModern": true,
    "IsAntiPattern": false,
    "ModernRelevance": "WPF/MAUIのMVVMにおける`ICommand`バインディングの基礎です。さらに、クラウドネイティブなシステム設計においては、CQRS（Command Query Responsibility Segregation）アーキテクチャの中核として、書き込み操作（Command）と読み取り操作（Query）を分離するために不可欠な概念となっています。",
    "Sections": [
      {
        "Title": "本質：メソッド呼び出しのオブジェクト化",
        "Content": "Commandパターンの本質は、「処理の依頼（Invocation）」を「処理の実体（Execution）」から切り離すことにあります。\n\n通常、`button.Click` イベントハンドラに直接ロジックを書くと、そのロジックはボタンと強く結合します。Commandパターンでは、ロジックを独立したクラス（またはデリゲート）にカプセル化します。\n\nこれにより、以下の「スーパーパワー」が得られます：\n1. **Undo/Redo**: 操作をスタックに積むことで、逆操作を実行可能にする。\n2. **マクロ記録**: 一連の操作をリストとして保存し、再生する。\n3. **トランザクション**: 複数の操作を不可分な単位として扱う。\n4. **非同期実行**: コマンドをキューに入れ、バックグラウンドワーカーに処理させる。",
        "ImagePath": ""
      },
      {
        "Title": "WPF/MVVMにおける実践的実装",
        "Content": "WPFでは `ICommand` インターフェースが標準装備されていますが、素のまま実装するのは冗長です。実務では `RelayCommand<T>` や `AsyncRelayCommand` を基盤とします。\n\n特に重要なのは `CanExecuteChanged` の制御です。WPFの `CommandManager` と連携させることで、UIの有効/無効状態を自動的に同期させることができます。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "public class RelayCommand<T> : ICommand\n{\n    private readonly Action<T> _execute;\n    private readonly Predicate<T> _canExecute;\n\n    public RelayCommand(Action<T> execute, Predicate<T> canExecute = null)\n    {\n        _execute = execute ?? throw new ArgumentNullException(nameof(execute));\n        _canExecute = canExecute;\n    }\n\n    public event EventHandler CanExecuteChanged\n    {\n        add { CommandManager.RequerySuggested += value; }\n        remove { CommandManager.RequerySuggested -= value; }\n    }\n\n    public bool CanExecute(object parameter) => _canExecute == null || _canExecute((T)parameter);\n\n    public void Execute(object parameter) => _execute((T)parameter);\n}",
          "Description": "CommandManager.RequerySuggestedを利用することで、フォーカス移動や入力変更時に自動的にCanExecuteが再評価され、ボタンの活性/非活性が即座に反映されます。"
        }
      },
      {
        "Title": "WinFormsにおけるCommandパターンの適用",
        "Content": "WinFormsにはWPFのようなバインディング機構はありませんが、Commandパターンを適用することで「UIとロジックの分離」という恩恵を受けられます。\n\nボタンとコマンドを紐付ける `Binder` クラスを作成し、`Application.Idle` イベントを利用して `CanExecute` の状態を監視・反映させる手法が実践的です。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "// WinForms向けの簡易バインダー\npublic class CommandBinder\n{\n    public void Bind(Button button, ICommand command)\n    {\n        // クリック時の実行\n        button.Click += (s, e) => command.Execute(null);\n\n        // アイドル時にCanExecuteをチェックしてEnabledを更新\n        EventHandler handler = (s, e) => \n        {\n            button.Enabled = command.CanExecute(null);\n        };\n        \n        Application.Idle += handler;\n        \n        // メモリリーク防止のため、Dispose等で解除する仕組みが必要ですが簡略化しています\n        button.Disposed += (s, e) => Application.Idle -= handler;\n    }\n}",
          "Description": "これにより、WinFormsでも「ロジックの状態（CanExecute）」に基づいてUIの表示制御を自動化できます。スパゲッティコード化したイベントハンドラを一掃できます。"
        }
      },
      {
        "Title": "高度な応用：Undo/Redoシステムの実装",
        "Content": "Commandパターンの真骨頂はUndo/Redoです。これを実現するには、`Execute` の逆を行う `UnExecute` を定義する必要があります。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "public interface IUndoableCommand : ICommand\n{\n    void UnExecute();\n}\n\npublic class CommandManager\n{\n    private readonly Stack<IUndoableCommand> _undoStack = new();\n    private readonly Stack<IUndoableCommand> _redoStack = new();\n\n    public void Execute(IUndoableCommand command)\n    {\n        command.Execute(null);\n        _undoStack.Push(command);\n        _redoStack.Clear(); // 新しい操作をしたらRedo履歴は消す\n    }\n\n    public void Undo()\n    {\n        if (_undoStack.Count == 0) return;\n        var cmd = _undoStack.Pop();\n        cmd.UnExecute();\n        _redoStack.Push(cmd);\n    }\n\n    public void Redo()\n    {\n        if (_redoStack.Count == 0) return;\n        var cmd = _redoStack.Pop();\n        cmd.Execute(null);\n        _undoStack.Push(cmd);\n    }\n}",
          "Description": "テキストエディタやグラフィックソフトのような「元に戻す」機能も、この設計なら驚くほどシンプルに実装できます。"
        }
      }
    ]
  },
  {
    "Id": "state",
    "Name": "State Pattern",
    "Summary": "オブジェクトの内部状態に応じて振る舞いを変更するパターン。状態特有のロジックをクラスに分離し、巨大な条件分岐を排除する。",
    "Category": "Behavioral",
    "Difficulty": "Advanced",
    "IsModern": true,
    "IsAntiPattern": false,
    "ModernRelevance": "ゲーム開発（キャラクターのAI）、通信プロトコル（TCP接続状態）、ワークフローエンジンなどで必須の知識です。現代のC#では、クラスによる実装だけでなく、`switch` 式と `record` を組み合わせた関数型アプローチ（Statelessライブラリ等）も人気があります。",
    "Sections": [
      {
        "Title": "本質：ポリモーフィズムによる分岐の排除",
        "Content": "「状態」を持つオブジェクトのメソッドは、しばしば巨大な `switch` 文や `if-else` の塊になります。\n\n```csharp\npublic void Request() {\n    if (state == Draft) { ... }\n    else if (state == Review) { ... }\n    else if (state == Published) { ... }\n}\n```\n\nStateパターンは、この「状態」をクラスとして切り出し、**委譲**によって振る舞いを切り替えます。これにより、新しい状態を追加する際に既存のコード（Context）を修正する必要がなくなります。",
        "ImagePath": ""
      },
      {
        "Title": "実践的実装：ライフサイクル管理 (Enter/Exit)",
        "Content": "実務レベルのStateパターンでは、単にメソッドを呼ぶだけでなく、状態遷移時の「初期化（Enter）」と「終了処理（Exit）」が重要になります。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "public abstract class State\n{\n    public virtual void Enter(Context context) { } // 状態に入った時\n    public virtual void Exit(Context context) { }  // 状態から出る時\n    public abstract void Handle(Context context);\n}\n\npublic class Context\n{\n    private State _currentState;\n    public Context(State initialState)\n    {\n        TransitionTo(initialState);\n    }\n\n    public void TransitionTo(State newState)\n    {\n        _currentState?.Exit(this);\n        _currentState = newState;\n        Console.WriteLine($\"Transitioned to {newState.GetType().Name}\");\n        _currentState.Enter(this);\n    }\n\n    public void Request() => _currentState.Handle(this);\n}",
          "Description": "この `TransitionTo` メソッドのように、遷移のロジックを一箇所に集約することで、ログ出力やバリデーション、リソースのクリーンアップを一貫して行えます。"
        }
      },
      {
        "Title": "モダンC#：Switch式による軽量FSM",
        "Content": "状態ごとの振る舞いがそれほど複雑でない場合、クラスを量産するのはオーバーエンジニアリングです。C# 8.0以降の `switch` 式を使うと、宣言的に状態遷移を記述できます。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "enum State { Idle, Running, Paused }\nenum Command { Start, Pause, Stop }\n\nState Transition(State current, Command command) => (current, command) switch\n{\n    (State.Idle, Command.Start) => State.Running,\n    (State.Running, Command.Pause) => State.Paused,\n    (State.Paused, Command.Start) => State.Running,\n    (State.Running, Command.Stop) => State.Idle,\n    _ => throw new InvalidOperationException(\"Invalid transition\")\n};\n\n// Usage\nvar newState = Transition(State.Idle, Command.Start); // Running",
          "Description": "「振る舞い（メソッド）」が主役ならクラスベースのStateパターン、「遷移（データ）」が主役ならこの関数型アプローチが適しています。"
        }
      }
    ]
  },
  {
    "Id": "template-method",
    "Name": "Template Method Pattern",
    "Summary": "処理のアルゴリズムの骨格をスーパークラスで定義し、その一部の具体的な手順をサブクラスで実装するパターン。",
    "Category": "Behavioral",
    "Difficulty": "Beginner",
    "IsModern": true,
    "IsAntiPattern": false,
    "ModernRelevance": "フレームワークやライブラリの設計（フックメソッドなど）でよく使われます。ただし、継承を強制するため、Strategyパターンの方が柔軟性が高い場合もあります。",
    "Sections": [
      {
        "Title": "イントロダクション：レシピ",
        "Content": "料理のレシピを考えてみましょう。「お湯を沸かす」「具材を入れる」「煮込む」という手順はカレーでもシチューでも同じです。「具材」や「味付け」だけが違います。\n\nTemplate Methodパターンは、この「共通の手順」を親クラスに定義し、「違う部分」だけを子クラスに任せます。",
        "ImagePath": ""
      },
      {
        "Title": "実装例",
        "Content": "抽象クラスに `TemplateMethod` を定義し、その中で抽象メソッドを呼び出します。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "public abstract class Cooking\n{\n    // Template Method\n    public void Cook()\n    {\n        BoilWater();\n        AddIngredients(); // 抽象メソッド\n        Simmer();\n    }\n\n    protected abstract void AddIngredients();\n    \n    private void BoilWater() => Console.WriteLine(\"Boiling water...\");\n    private void Simmer() => Console.WriteLine(\"Simmering...\");\n}",
          "Description": "親クラスが処理の流れ（制御）を握っているのが特徴です（ハリウッドの原則：Don't call us, we'll call you）。"
        }
      }
    ]
  },
  {
    "Id": "singleton",
    "Name": "Singleton Pattern",
    "Summary": "クラスのインスタンスが1つしか生成されないことを保証するパターン。",
    "Category": "Creational",
    "Difficulty": "Beginner",
    "IsModern": false,
    "IsAntiPattern": true,
    "ModernRelevance": "現代の設計、特に単体テストを重視する環境では**アンチパターン**とされることが多いです。グローバルな状態を持ち、依存関係を隠蔽してしまうためです。代わりにDIコンテナの `Singleton` ライフサイクルを使用すべきです。",
    "Sections": [
      {
        "Title": "なぜアンチパターンなのか？",
        "Content": "かつては便利に使われていたSingletonですが、現在は以下の理由で嫌われています：\n1. **密結合**: 利用する側が具体的なクラス名に依存してしまう。\n2. **テスト困難**: グローバルな状態を持つため、テスト間の干渉が起きやすい。モックに差し替えるのが難しい。\n3. **隠された依存**: コンストラクタを見ても何に依存しているかわからない。",
        "ImagePath": ""
      },
      {
        "Title": "現代的な解決策：DIコンテナ",
        "Content": "クラス自体をSingletonにするのではなく、**「使い方がSingleton」**であるようにDIコンテナに管理させます。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "// 悪い例：自前Singleton\npublic class Database\n{\n    public static Database Instance { get; } = new Database();\n    private Database() { }\n}\n\n// 良い例：普通のクラスとして定義し、DIで寿命管理\nservices.AddSingleton<IDatabase, Database>();",
          "Description": "これにより、テスト時には `IDatabase` のモックを渡すことが容易になります。"
        }
      }
    ]
  },
  {
    "Id": "builder",
    "Name": "Builder Pattern",
    "Summary": "複雑なオブジェクトの生成過程を分離し、同じ生成過程で異なる表現形式のオブジェクトを生成できるようにするパターン。",
    "Category": "Creational",
    "Difficulty": "Intermediate",
    "IsModern": true,
    "IsAntiPattern": false,
    "ModernRelevance": "Fluent Interface（メソッドチェーン）として非常に広く使われています。StringBuilderやASP.NET Coreの構成（HostBuilder）などが代表例です。",
    "Sections": [
      {
        "Title": "イントロダクション：コンストラクタ地獄",
        "Content": "引数が10個あるコンストラクタを見たことはありませんか？どれがどのパラメータか分からず、nullを渡すのも面倒です。\n\nBuilderパターンを使えば、必要なパラメータだけを分かりやすいメソッド名で設定し、最後に `Build()` でオブジェクトを生成できます。",
        "ImagePath": ""
      },
      {
        "Title": "実装例：Fluent Builder",
        "Content": "自分自身を返すメソッドを定義することで、メソッドチェーンを実現します。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "public class Pizza\n{\n    public string Dough { get; set; }\n    public string Sauce { get; set; }\n    public string Topping { get; set; }\n}\n\npublic class PizzaBuilder\n{\n    private Pizza _pizza = new Pizza();\n\n    public PizzaBuilder WithDough(string dough)\n    {\n        _pizza.Dough = dough;\n        return this;\n    }\n\n    public PizzaBuilder WithSauce(string sauce)\n    {\n        _pizza.Sauce = sauce;\n        return this;\n    }\n\n    public Pizza Build() => _pizza;\n}\n\n// Usage\nvar pizza = new PizzaBuilder()\n    .WithDough(\"Thin\")\n    .WithSauce(\"Tomato\")\n    .Build();",
          "Description": "読みやすく、パラメータの順序も気にする必要がありません。"
        }
      }
    ]
  },
  {
    "Id": "abstract-factory",
    "Name": "Abstract Factory Pattern",
    "Summary": "関連する一連のオブジェクトを生成するためのインターフェースを提供し、具体的なクラスを指定せずに生成できるようにするパターン。",
    "Category": "Creational",
    "Difficulty": "Advanced",
    "IsModern": true,
    "IsAntiPattern": false,
    "ModernRelevance": "クロスプラットフォーム開発（UI部品の生成など）や、データベースの切り替えなどで有効です。DIコンテナと組み合わせることで、設定一つでアプリケーション全体の振る舞い（使用するクラス群）を切り替えることができます。",
    "Sections": [
      {
        "Title": "イントロダクション：テーマ切り替え",
        "Content": "「Windows風のボタンとウィンドウ」「Mac風のボタンとウィンドウ」を作りたいとします。バラバラに生成すると、WindowsのボタンとMacのウィンドウが混ざってしまうかもしれません。\n\nAbstract Factoryは「製品ファミリー」をまとめて生成する工場を定義します。",
        "ImagePath": ""
      },
      {
        "Title": "実装例",
        "Content": "工場（Factory）のインターフェースを定義し、具体的な工場（WindowsFactory, MacFactory）がそれを実装します。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "public interface IUIFactory\n{\n    IButton CreateButton();\n    IWindow CreateWindow();\n}\n\npublic class WindowsFactory : IUIFactory\n{\n    public IButton CreateButton() => new WindowsButton();\n    public IWindow CreateWindow() => new WindowsWindow();\n}\n\n// Client\npublic class Application\n{\n    private readonly IUIFactory _factory;\n    public Application(IUIFactory factory)\n    {\n        _factory = factory;\n    }\n    public void Render() \n    {\n        var btn = _factory.CreateButton(); // 何のOSか知らなくて良い\n    }\n}",
          "Description": "クライアントコードは具体的なOSの実装から完全に切り離されます。"
        }
      }
    ]
  },
  {
    "Id": "decorator",
    "Name": "Decorator Pattern",
    "Summary": "オブジェクトに動的に責任（機能）を追加するパターン。継承よりも柔軟な拡張が可能。",
    "Category": "Structural",
    "Difficulty": "Intermediate",
    "IsModern": true,
    "IsAntiPattern": false,
    "ModernRelevance": "ASP.NET CoreのMiddlewareパイプラインや、Stream（FileStreamにGZipStreamを被せるなど）の設計はまさにDecoratorです。AOP（アスペクト指向プログラミング）の基礎とも言えます。",
    "Sections": [
      {
        "Title": "イントロダクション：マトリョーシカ",
        "Content": "「コーヒー」クラスに「ミルク入り」「砂糖入り」「ミルクと砂糖入り」...と継承でクラスを作っていくと、クラス数が爆発します。\n\nDecoratorパターンは、オブジェクトを「ラップ（包む）」することで機能を上乗せします。マトリョーシカのように何重にも包むことができます。",
        "ImagePath": ""
      },
      {
        "Title": "実装例",
        "Content": "共通のインターフェースを持ち、コンストラクタで「包む対象」を受け取ります。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "public interface ICoffee\n{\n    int GetCost();\n}\n\npublic class SimpleCoffee : ICoffee\n{\n    public int GetCost() => 100;\n}\n\npublic class MilkDecorator : ICoffee\n{\n    private readonly ICoffee _coffee;\n    public MilkDecorator(ICoffee coffee) => _coffee = coffee;\n\n    public int GetCost() => _coffee.GetCost() + 50;\n}\n\n// Usage\nvar myCoffee = new MilkDecorator(new SimpleCoffee()); // 150円",
          "Description": "既存のクラスを変更することなく、機能を「装飾」できます。"
        }
      }
    ]
  },
  {
    "Id": "proxy",
    "Name": "Proxy Pattern",
    "Summary": "あるオブジェクトへのアクセスを制御するために、その代理（プロキシ）となるオブジェクトを置くパターン。",
    "Category": "Structural",
    "Difficulty": "Intermediate",
    "IsModern": true,
    "IsAntiPattern": false,
    "ModernRelevance": "Entity FrameworkのLazy Loading（遅延読み込み）や、WCF/gRPCのクライアントプロキシなど、リモート呼び出しや重い処理の制御に不可欠です。",
    "Sections": [
      {
        "Title": "イントロダクション：代理人",
        "Content": "社長（重いオブジェクト）に会う前に、秘書（Proxy）が用件を聞きます。簡単な用件なら秘書が答え、重要な用件だけ社長に取り次ぎます。\n\nこれにより、メモリの節約やセキュリティチェックが可能になります。",
        "ImagePath": ""
      },
      {
        "Title": "実装例：仮想プロキシ（遅延初期化）",
        "Content": "実際に必要になるまで、重いオブジェクトを生成しません。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "public interface IImage\n{\n    void Display();\n}\n\npublic class RealImage : IImage\n{\n    public RealImage(string filename) => Console.WriteLine($\"Loading {filename}...\");\n    public void Display() => Console.WriteLine(\"Displaying image.\");\n}\n\npublic class ProxyImage : IImage\n{\n    private RealImage _realImage;\n    private string _filename;\n\n    public ProxyImage(string filename) => _filename = filename;\n\n    public void Display()\n    {\n        if (_realImage == null)\n            _realImage = new RealImage(_filename);\n        _realImage.Display();\n    }\n}",
          "Description": "クライアントはProxyを使っていることに気づきません。"
        }
      }
    ]
  },
  {
    "Id": "facade",
    "Name": "Facade Pattern",
    "Summary": "複雑なサブシステムに対するシンプルで統一されたインターフェースを提供するパターン。",
    "Category": "Structural",
    "Difficulty": "Beginner",
    "IsModern": true,
    "IsAntiPattern": false,
    "ModernRelevance": "ライブラリやAPIの設計において、「使いやすいAPI」を提供するために重要です。複雑な内部クラス群を隠蔽し、ユーザーにはシンプルなメソッドだけを見せます。",
    "Sections": [
      {
        "Title": "イントロダクション：窓口",
        "Content": "家を建てるとき、大工、電気屋、配管工...それぞれに個別に指示を出すのは大変です。「現場監督（Facade）」がいれば、監督に「キッチンを作って」と言うだけで済みます。",
        "ImagePath": ""
      },
      {
        "Title": "実装例",
        "Content": "複数のクラスのメソッドを組み合わせて、高レベルな機能を提供します。",
        "CodeSample": {
          "Language": "csharp",
          "Code": "// 複雑なサブシステム\nclass Audio { public void On() {} }\nclass Video { public void On() {} }\nclass Lights { public void Dim() {} }\n\n// Facade\npublic class HomeTheaterFacade\n{\n    private Audio _audio = new Audio();\n    private Video _video = new Video();\n    private Lights _lights = new Lights();\n\n    public void WatchMovie()\n    {\n        _lights.Dim();\n        _audio.On();\n        _video.On();\n        Console.WriteLine(\"Movie started!\");\n    }\n}",
          "Description": "クライアントコードが劇的にシンプルになります。"
        }
      }
    ]
  }
]